//-----------------------------------------------------------------------------
// Brainfuck BASIC compiler
// Copyright (c) Paulo Custodio 2026
// License: The Artistic License 2.0, http ://www.perlfoundation.org/artistic_license_2_0
//-----------------------------------------------------------------------------

#include "codegen.h"
#include <algorithm>
#include <cassert>

CodeGen::CodeGen(SymbolTable& sym)
    : sym(sym), temp_counter(0) {
}

std::string CodeGen::generate(const Program& prog) {
    out.clear();

    emit_prelude();
    emit_var_allocs();

    for (const auto& s : prog.statements) {
        emit_stmt(s);
    }

    emit_postlude();
    return out;
}

void CodeGen::emit(const std::string& line) {
    out += line;
    out += "\n";
}

std::string CodeGen::alloc_temp16() {
    std::string name = "_BFB" + std::to_string(++temp_counter);
    emit("alloc_cell16(" + name + ")");
    return name;
}

void CodeGen::free_temp16(const std::string& name) {
    emit("free_cell16(" + name + ")");
}

std::vector<std::string> CodeGen::sorted_variable_names() const {
    std::vector<std::string> names;
    for (auto& [name, sym] : sym.all()) {
        names.push_back(name);
    }

    std::sort(names.begin(), names.end());
    return names;
}

void CodeGen::emit_prelude() {
    emit("// Generated by bfbasic, see https://github.com/pauloscustodio/bf");
}

void CodeGen::emit_postlude() {
    // optional: free vars, runtime cleanup
    // for now, do nothing
}

void CodeGen::emit_var_allocs() {
    auto names = sorted_variable_names();
    for (const auto& name : names) {
        const Symbol& s = sym.get(name);
        if (!s.allocated) {
            emit("alloc_cell16(" + name + ")");
            sym.mark_allocated(name);
        }
    }
}

void CodeGen::emit_stmt(const Stmt& s) {
    switch (s.type) {
    case Stmt::Type::Let:
        emit_let(s);
        break;
    case Stmt::Type::Input:
        emit_input(s);
        break;
    case Stmt::Type::Print:
        emit_print(s);
        break;
    default:
        assert(0);
    }
}

void CodeGen::emit_input(const Stmt& s) {
    emit("scan_cell16s(" + s.var + ")");
}

void CodeGen::emit_print(const Stmt& s) {
    emit("print_cell16s(" + s.var + ")");
    emit("print_newline");
}

void CodeGen::emit_let(const Stmt& s) {
    // Case 1: LET A = <constant>
    if (s.expr->type == Expr::Type::Number) {
        emit("set16(" + s.var + ", " + std::to_string(s.expr->value) + ")");
        return;
    }

    // Case 2: LET A = B
    if (s.expr->type == Expr::Type::Var) {
        emit("copy16(" + s.expr->name + ", " + s.var + ")");
        return;
    }

    // General case: LET A = <complex expression>
    std::string t = alloc_temp16();
    emit_expr(*s.expr, t);
    emit("move16(" + t + ", " + s.var + ")");
    free_temp16(t);
}

// expr result goes into target (16-bit cell name)
void CodeGen::emit_expr(const Expr& e, const std::string& target) {
    switch (e.type) {
    case Expr::Type::Number:
        emit("set16(" + target + ", " + std::to_string(e.value) + ")");
        break;

    case Expr::Type::Var:
        emit("copy16(" + e.name + ", " + target + ")");
        break;

    case Expr::Type::BinOp:
        emit_binary(e, target);
        break;

    case Expr::Type::UnaryOp:
        emit_unary(e, target);
        break;

    default:
        assert(0);
    }
}

void CodeGen::emit_unary(const Expr& e, const std::string& target) {
    // Evaluate inner into target
    emit_expr(*e.inner, target);

    switch (e.op) {
    case TokenType::Plus:
        // no-op
        break;

    case TokenType::Minus:
        emit("neg16(" + target + ")");
        break;

    case TokenType::Not:
        // NOT x  ->  (x == 0)
        emit("not16(" + target + ")");
        break;

    default:
        assert(0);
    }
}

void CodeGen::emit_binary(const Expr& e, const std::string& target) {
    // Evaluate left into target
    emit_expr(*e.left, target);

    // Evaluate right into a temp
    std::string tmp = alloc_temp16();
    emit_expr(*e.right, tmp);

    switch (e.op) {

    // Arithmetic
    case TokenType::Plus:
        emit("add16s(" + target + ", " + tmp + ")");
        break;
    case TokenType::Minus:
        emit("sub16s(" + target + ", " + tmp + ")");
        break;
    case TokenType::Star:
        emit("mul16s(" + target + ", " + tmp + ")");
        break;
    case TokenType::Slash:
        emit("div16s(" + target + ", " + tmp + ")");
        break;
    case TokenType::Mod:
        emit("mod16s(" + target + ", " + tmp + ")");
        break;
    case TokenType::Caret:
        emit("pow16s(" + target + ", " + tmp + ")");
        break;

    // Shifts
    case TokenType::Shl:
        emit("shl16(" + target + ", " + tmp + ")");
        break;
    case TokenType::Shr:
        emit("shr16(" + target + ", " + tmp + ")");
        break;

    // Relational (normalize to 0/1)
    case TokenType::Equal:
        emit("eq16s(" + target + ", " + tmp + ")");
        break;
    case TokenType::NotEqual:
        emit("ne16s(" + target + ", " + tmp + ")");
        break;
    case TokenType::Less:
        emit("lt16s(" + target + ", " + tmp + ")");
        break;
    case TokenType::LessEqual:
        emit("le16s(" + target + ", " + tmp + ")");
        break;
    case TokenType::Greater:
        emit("gt16s(" + target + ", " + tmp + ")");
        break;
    case TokenType::GreaterEqual:
        emit("ge16s(" + target + ", " + tmp + ")");
        break;

    // Boolean logic (operates on 0/1)
    case TokenType::And:
        emit("and16(" + target + ", " + tmp + ")");
        break;
    case TokenType::Or:
        emit("or16(" + target + ", " + tmp + ")");
        break;
    case TokenType::Xor:
        emit("xor16(" + target + ", " + tmp + ")");
        break;

    default:
        assert(0);
    }

    free_temp16(tmp);
}