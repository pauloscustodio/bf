//-----------------------------------------------------------------------------
// Brainfuck BASIC compiler
// Copyright (c) Paulo Custodio 2026
// License: The Artistic License 2.0, http ://www.perlfoundation.org/artistic_license_2_0
//-----------------------------------------------------------------------------

#include "codegen.h"
#include <algorithm>
#include <cassert>

CodeGen::CodeGen(SymbolTable& sym)
    : sym(sym), temp_counter(0) {
}

std::string CodeGen::generate(const Program& prog) {
    out.clear();

    emit_prelude();
    emit_var_allocs();

    for (const auto& s : prog.statements) {
        emit_stmt(*s);
    }

    emit_postlude();
    return out;
}

void CodeGen::emit(const std::string& line) {
    out += line;
    out += "\n";
}

std::string CodeGen::alloc_temp16() {
    std::string name = "_BFB" + std::to_string(++temp_counter);
    emit("alloc_cell16(" + name + ")");
    return name;
}

void CodeGen::free_temp16(const std::string& name) {
    emit("free_cell16(" + name + ")");
}

std::vector<std::string> CodeGen::sorted_variable_names() const {
    std::vector<std::string> names;
    for (auto& [name, sym] : sym.all()) {
        names.push_back(name);
    }

    std::sort(names.begin(), names.end());
    return names;
}

void CodeGen::emit_prelude() {
    emit("// Generated by bfbasic, see https://github.com/pauloscustodio/bf");
}

void CodeGen::emit_postlude() {
    // optional: free vars, runtime cleanup
    // for now, do nothing
}

void CodeGen::emit_var_allocs() {
    auto names = sorted_variable_names();
    for (const auto& name : names) {
        const Symbol& s = sym.get(name);
        if (!s.allocated) {
            emit("alloc_cell16(" + name + ")");
            sym.mark_allocated(name);
        }
    }
}

void CodeGen::emit_stmt(const Stmt& s) {
    switch (s.type) {
    case StmtType::Let:
        emit_let(s);
        break;
    case StmtType::Input:
        emit_input(s);
        break;
    case StmtType::Print:
        emit_print(s);
        break;
    case StmtType::If:
        emit_if(s);
        break;
    case StmtType::While:
        emit_while(s);
        break;
    default:
        assert(0);
    }
}

void CodeGen::emit_input(const Stmt& s) {
    for (auto& v : s.vars) {
        emit("scan_cell16s(" + v + ")");
    }
}

void CodeGen::emit_print(const Stmt& s) {
    const StmtPrint& p = s.print;
    bool last_was_separator = false;

    for (const auto& e : p.elems) {
        switch (e.type) {

        case PrintElemType::String:
            emit("print_string(\"" + escape(e.text) + "\")");
            last_was_separator = false;
            break;

        case PrintElemType::Expr: {
            if (e.expr.type == Expr::Type::Var) {
                emit("print_cell16s(" + e.expr.name + ")");
            }
            else {
                std::string tmp = alloc_temp16();
                emit_expr(e.expr, tmp);
                emit("print_cell16s(" + tmp + ")");
                free_temp16(tmp);
            }
            last_was_separator = false;
            break;
        }

        case PrintElemType::Separator:
            if (e.sep == TokenType::Comma) {
                emit("print_char(9)");    // tab
            }
            // semicolon prints nothing
            last_was_separator = true;
            break;
        }
    }

    // newline unless last element was a semicolon
    if (!last_was_separator) {
        emit("print_newline");
    }
}


std::string CodeGen::escape(const std::string& s) {
    std::string result;
    result.reserve(s.size());
    for (auto c : s) {
        if (c == '"') {
            result += "\\\"";
        }
        else {
            result.push_back(c);
        }
    }

    return result;
}

void CodeGen::emit_let(const Stmt& s) {
    assert(s.vars.size() == 1); // only single-variable LET supported for now
    std::string  var = s.vars[0];

    // Case 1: LET A = <constant>
    if (s.expr->type == Expr::Type::Number) {
        emit("set16(" + var + ", " + std::to_string(s.expr->value) + ")");
        return;
    }

    // Case 2: LET A = B
    if (s.expr->type == Expr::Type::Var) {
        emit("copy16(" + s.expr->name + ", " + var + ")");
        return;
    }

    // General case: LET A = <complex expression>
    std::string t = alloc_temp16();
    emit_expr(*s.expr, t);
    emit("move16(" + t + ", " + var + ")");
    free_temp16(t);
}

void CodeGen::emit_if(const Stmt& s) {
    const StmtIf& stmt_if = *s.if_stmt;

    // 1. Evaluate condition into a temp cell
    std::string cond = alloc_temp16();
    emit_expr(stmt_if.condition, cond);

    // 2. Begin IF
    emit("if(" + cond + ")");

    // 3. THEN block
    for (auto& stmt : stmt_if.then_block.statements) {
        emit_stmt(*stmt);
    }

    // 4. ELSE block (optional)
    if (!stmt_if.else_block.statements.empty()) {
        emit("else");
        for (auto& stmt : stmt_if.else_block.statements) {
            emit_stmt(*stmt);
        }
    }

    // 5. ENDIF
    emit("endif");

    // 6. Free temp
    free_temp16(cond);
}

void CodeGen::emit_while(const Stmt& s) {
    const StmtWhile& stmt_while = *s.while_stmt;

    // 1. Allocate temp for condition
    std::string cond = alloc_temp16();

    // 2. Initial evaluation
    emit_expr(stmt_while.condition, cond);

    // 3. While header
    emit("while(" + cond + ")");

    // 4. Body
    for (auto& stmt : stmt_while.body.statements) {
        emit_stmt(*stmt);
    }

    // 5. Re-evaluate condition at loop bottom
    emit_expr(stmt_while.condition, cond);

    // 6. End of loop
    emit("endwhile");

    // 7. Free temp
    free_temp16(cond);
}

// expr result goes into target (16-bit cell name)
void CodeGen::emit_expr(const Expr& e, const std::string& target) {
    switch (e.type) {
    case Expr::Type::Number:
        emit("set16(" + target + ", " + std::to_string(e.value) + ")");
        break;

    case Expr::Type::Var:
        emit("copy16(" + e.name + ", " + target + ")");
        break;

    case Expr::Type::BinOp:
        emit_binary(e, target);
        break;

    case Expr::Type::UnaryOp:
        emit_unary(e, target);
        break;

    default:
        assert(0);
    }
}

void CodeGen::emit_unary(const Expr& e, const std::string& target) {
    // Evaluate inner into target
    emit_expr(*e.inner, target);

    switch (e.op) {
    case TokenType::Plus:
        // no-op
        break;

    case TokenType::Minus:
        emit("neg16(" + target + ")");
        break;

    case TokenType::KeywordNot:
        // NOT x  ->  (x == 0)
        emit("not16(" + target + ")");
        break;

    default:
        assert(0);
    }
}

void CodeGen::emit_binary(const Expr& e, const std::string& target) {
    // Evaluate left into target
    emit_expr(*e.left, target);

    // Evaluate right into a temp
    std::string tmp = alloc_temp16();
    emit_expr(*e.right, tmp);

    switch (e.op) {

    // Arithmetic
    case TokenType::Plus:
        emit("add16s(" + target + ", " + tmp + ")");
        break;
    case TokenType::Minus:
        emit("sub16s(" + target + ", " + tmp + ")");
        break;
    case TokenType::Star:
        emit("mul16s(" + target + ", " + tmp + ")");
        break;
    case TokenType::Slash:
        emit("div16s(" + target + ", " + tmp + ")");
        break;
    case TokenType::KeywordMod:
        emit("mod16s(" + target + ", " + tmp + ")");
        break;
    case TokenType::Caret:
        emit("pow16s(" + target + ", " + tmp + ")");
        break;

    // Shifts
    case TokenType::KeywordShl:
        emit("shl16(" + target + ", " + tmp + ")");
        break;
    case TokenType::KeywordShr:
        emit("shr16(" + target + ", " + tmp + ")");
        break;

    // Relational (normalize to 0/1)
    case TokenType::Equal:
        emit("eq16s(" + target + ", " + tmp + ")");
        break;
    case TokenType::NotEqual:
        emit("ne16s(" + target + ", " + tmp + ")");
        break;
    case TokenType::Less:
        emit("lt16s(" + target + ", " + tmp + ")");
        break;
    case TokenType::LessEqual:
        emit("le16s(" + target + ", " + tmp + ")");
        break;
    case TokenType::Greater:
        emit("gt16s(" + target + ", " + tmp + ")");
        break;
    case TokenType::GreaterEqual:
        emit("ge16s(" + target + ", " + tmp + ")");
        break;

    // Boolean logic (operates on 0/1)
    case TokenType::KeywordAnd:
        emit("and16(" + target + ", " + tmp + ")");
        break;
    case TokenType::KeywordOr:
        emit("or16(" + target + ", " + tmp + ")");
        break;
    case TokenType::KeywordXor:
        emit("xor16(" + target + ", " + tmp + ")");
        break;

    default:
        assert(0);
    }

    free_temp16(tmp);
}